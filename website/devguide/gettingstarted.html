<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Okapi Framework Developer's Guide - Getting Started</title>
<link rel="stylesheet" type="text/css" href="../okapi.css">
</head>

<body>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
	<tr class="head">
		<td class="head" colspan="2"><h1 class="head">Okapi Framework - Developer's Guide</h1>
		<h2 class="head2">Getting Started</h2></td>
	</tr>
	<tr>
		<td class="smalltoc"><p>
			- <a href="#overview">Overview</a><br/>
			- <a href="#readingDocument">Reading a Document</a><br/>
			- <a href="#modifyingDocument">Modifying a Document</a><br/>
			- <a href="#textUnits">Working with Text Units</a></p></td>
		<td class="hmenu">
			<div class="hmenu"><table align="right"><tr>
				<td><a href="glossary.html">Glossary</a></td>
				<td><a href="index.html">Guide Content</a></td>
				<td><a href="http://okapiframework.org">Okapi Framework</a></td>
			</tr></table></div>
		</td>
	</tr>
</table>

<h2><a name="overview"></a>Overview</h2>
<p>Applications like Rainbow are built on top of the framework, but it is quite 
easy to develop other tools and scripts that use directly the framework components. 
With these components you can do things like:</p>
<ul>
	<li>Read documents in different formats into a set of standardized resources.</li>
	<li>Store the extracted text into a common representation, where text is 
	separated from inline codes.</li>
	<li>Manipulate the extracted text and any modifiable 
	properties associated with it.</li>
	<li>Re-write the document in its original format, but with its extractable 
	parts modified if needed.</li>
	<li>Segment extracted text into sentences.</li>
	<li>Chain sequences of independent steps that perform different actions on 
	the resources generated by the filters.</li>
	<li>and much more...</li>
</ul>
<p>This section describes how to write simple programs that use the Okapi 
Framework components to perform simple tasks such as reading and modifying a 
document.</p>
<h2><a name="readingDocument"></a>Reading a Document</h2>
<p>One of the most important actors in the framework is the 
<a href="glossary.html#filter">filter</a>. All 
filters are accessible through a single common API: the <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html">IFilter</a></code> 
interface. They take an input document in a given format and generate 
<a href="glossary.html#event">events</a> 
that give you access to the extractable text of the document, as well as the 
properties associated to it.</p>
<p class="question"><b>Question</b>: Are these events like Java AWT events, 
working with a listener, etc?</p>
<p class="answer" dir="ltr"><b>Answer</b>: Not at all. In the context of the framework, an 
&quot;event&quot; is not related to Java &quot;listeners&quot; or an &quot;event sinks&quot;. They are just 
the units of information (possibly with attached data) that are used to 
communicate between components. In the case of <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html">IFilter</a></code>, 
events are obtained from the <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#next()">
IFilter.next()</a></code> method.</p>
<p>The filters are designed to work through a 
<a href="glossary.html#pipeline">pipeline</a>. A pipeline is a 
set of sequential steps, each step receiving events, processing it (if needed) and 
sending it to the next step. The framework has pre-defined components to build and execute 
pipelines easily, but we will see that later.</p>
<p>For now, let's concentrate on the filter itself. You do not need to use a pipeline to work with filters, as long as you know 
what event to send and receive.</p>
<p>Most events have associated <a href="glossary.html#resource">resources</a>. Each resource is different depending 
on the type of event. Extracted text, properties, as well as grouping 
information are carried in those resources. The following table show all the 
kinds of event that can go through a pipeline.</p>
<p><a name="eventsAndResources"></a>Events and Corresponding Resources:</p>
<table border="1" id="table1" cellspacing="0" cellpadding="4">
	<tr>
		<th>Events</th>
		<th>Resource</th>
		<th>Filter-Specific Event?</th>
	</tr>
	<tr>
		<td><code>START_BATCH</code></td>
		<td>none</td>
		<td>no (starts a batch)</td>
	</tr>
	<tr>
		<td><code>START_BATCH_ITEM</code></td>
		<td>none</td>
		<td>no (starts a batch item)</td>
	</tr>
	<tr>
		<td><code>RAW_DOCUMENT</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/RawDocument.html">
		RawDocument</a></code></td>
		<td>no (corresponds to a document by itself).</td>
	</tr>
	<tr>
		<td><code>START_DOCUMENT</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/StartDocument.html">StartDocument</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>START_SUBDOCUMENT</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/StartSubDocument.html">StartSubDocument</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>START_GROUP</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/StartGroup.html">StartGroup</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>DOCUMENT_PART</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/DocumentPart.html">
		DocumentPart</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>TEXT_UNIT</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html">TextUnit</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>END_GROUP</code></td>
		<td><code><a href="../javadoc/net/sf/okapi/common/resource/Ending.html">Ending</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>END_SUBDOCUMENT</code></td>
		<td><code><a href="../javadoc/net/sf/okapi/common/resource/Ending.html">Ending</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>END_DOCUMENT</code></td>
		<td><code><a href="../javadoc/net/sf/okapi/common/resource/Ending.html">Ending</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>CANCELED</code></td>
		<td>none</td>
		<td>no (used when a process is canceled)</td>
	</tr>
	<tr>
		<td><code>FINISHED</code></td>
		<td>none</td>
		<td>no (used at the end of a set of documents)</td>
	</tr>
	<tr>
		<td><code>NO_OP</code></td>
		<td>none</td>
		<td>no (used for no-operation)</td>
	</tr>
	<tr>
		<td><code>CUSTOM</code></td>
		<td>custom resource</td>
		<td>no (used for custom events)</td>
	</tr>
	<tr>
		<td><code>END_BATCH_ITEM</code></td>
		<td>none</td>
		<td>no (ends a batch item)</td>
	</tr>
	<tr>
		<td><code>END_BATCH</code></td>
		<td>none</td>
		<td>no (ends a batch)</td>
	</tr>
	</table>
<p>A filter always generates at least the <code>START_DOCUMENT</code> 
and <code>END_DOCUMENT</code> events. All other filter-specific events may or may not be generated depending on each filter and each 
document. See the section <a href="filters.html#filterEvents">Filter Events</a> 
for more details.</p>
<p>Any event that is not understood by a component should be simply passed along 
down the pipeline.</p>
<h3><a name="creatingFilter"></a>Creating the Filter</h3>
<p>To use a filter, you first have to create a filter object. The Okapi 
Framework provides you with several filters, and you can write your own as well. 
In the example below, we use the <code>
net.sf.okapi.filters.properties.PropertiesFilter</code> class which implements 
the <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html">IFilter</a></code> 
interface for Java Properties files.</p>
<pre>// Create a filter object
IFilter filter = new PropertiesFilter();</pre>
<h3><a name="settingParameters"></a>Setting the Filter Parameters</h3>
<p>Some filters have options that are specific to the format they parse. You can 
set these filter-specific parameters with the method
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#setParameters(net.sf.okapi.common.IParameters)">
<code>
IFilter.setParameters()</code></a>. The 
method <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#getParameters()">
IFilter.getParameters()</a></code> allows you to retrieve the current 
parameters.</p>
<p>The <code>PropertiesFilter</code> has such options, but the defaults are just 
fine for the example so we won't use any additional parameters.</p>
<p class="question"><b>Question</b>: Is there an easy way to edit the 
filter-specific parameters?</p>
<p class="answer"><b>Answer</b>: It depends. The parameters are accessible through the <code>
<a href="../javadoc/net/sf/okapi/common/IParameters.html">IParameters</a></code> 
interface and, at the least, this interface allows to save the parameters to a 
file, that file can be a simple property-like text file. Some filters also 
provide UI for modifying their parameters. See the
<a href="filters.html#filterParameters">Filter Parameters</a> section of the 
guide for more details.</p>
<h3><a name="openInputDoc"></a>Opening the Input Document</h3>
<p>The next step is to open the document. This is done with the help of an <code>
<a href="../javadoc/net/sf/okapi/common/resource/RawDocument.html">
RawDocument</a></code> object, which carries all the information the filter 
needs to open the input document:</p>
<ul>
	<li>The object representing the document to process. This can be one (and 
	only one) of the following:<ul>
	<li>a <code>CharSequence</code> object that contains the document itself. 
	(<code>String</code> is a type of <code>CharSequence</code>).</li>
	<li>a <code>URI</code> object pointing to the physical document.</li>
	<li>an <code>InputStream</code> object.</li>
</ul></li>
	<li>The default encoding of the document to process.</li>
	<li>The language/locale of the text to extract.</li>
	<li>And, optionally, the target language to work with (for multilingual 
	formats).</li>
</ul>
<p dir="ltr">In the code below we set the source language to English, using the 
same standard language tag identifiers you would use with HTML and XML (BCP-47). 
We set the default encoding to UTF-8. Note that some filters will be able to
automatically detect the correct encoding of the input and ignore this value.</p>
<pre>// Creates the RawDocument object
RawDocument res = new RawDocument(myInputStream, &quot;UTF-8&quot;, LocaleId.fromString(&quot;en&quot;));
// Opens the document
filter.open(res);</pre>
<p>By default a filter generates the 
	<a href="glossary.html#skeleton">skeleton</a> for 
	the document (we'll see more about the skeleton later). If, for some reason, 
you do not want to generate the skeleton you can specify an additional parameter 
and use:</p>
<pre>// Opens the document, without generating skeleton
filter.open(res, false);</pre>
<p class="question"><b>Question</b>: Why use an intermediate object for opening the document?
Wouldn't it be simpler to just pass the parameters to <code>
open()</code>?</p>
<p class="answer"><b>Answer</b>: The <code>
<a href="../javadoc/net/sf/okapi/common/resource/RawDocument.html">
RawDocument</a></code> object is used because in many cases filters are used 
in the broader environment of pipelines, where having all information about the 
input document in one object makes things much easier. The object is also the 
resource associated with the <code>RAW_DOCUMENT</code> event that allows to mix 
in the same pipeline steps using filter events or steps working on the input 
document directly.</p>
<p dir="ltr">Note that while the filters should do their best to implement all the 
different input objects, this may not be possible in some cases 
because of the format the filter deals with. For example, a&nbsp; filter for 
Adobe Photoshop PSD files does not support <code>CharSequence</code> input 
objects, as PSD files are binary.</p>
<p>In our example we want to open a <code>String</code>-based document:</p>
<pre>// Creates the RawDocument object
RawDocument res = new RawDocument(&quot;key1=Text1\nkey2=Text2&quot;, LocaleId.fromString(&quot;en&quot;));
// Opens the document
filter.open(res);</pre>
<p>This is equivalent to opening a physical properties file on the disk that has the 
following content:</p>
<pre>key1=Text1
key2=Text2</pre>
<h3><a name="processInputDoc"></a>Processing the Input Document</h3>
<p>Everything is now in place to start processing the input document.</p>
<p>We use the method <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#hasNext()">IFilter.hasNext()</a></code> to see if there is any event to access. If there is, 
we use 
the method <code><a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#next()">IFilter.next()</a></code> to get the actual event.</p>
<ul>
	<li>You must always call
	<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#hasNext()"><code>IFilter.hasNext()</code></a>
	before calling
	<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#next()"><code>IFilter.next()</code></a>.</li>
	<li>You must call
	<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#next()"><code>IFilter.next()</code></a> 
	once and only once before the next call to
	<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#hasNext()">
	<code>IFilter.hasNext()</code></a>.</li>
	<li>Do not rely on
	<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#next()"><code>IFilter.next()</code></a> 
	returning <code>null</code> if there are no more events.</li>
</ul>
<pre>// Proper call of hasNext() and next()
while ( filter.hasNext() ) {
   Event event = filter.next();
   // Do something...
}</pre>
<p>Once you have an event, you can query its type using <code>
<a href="../javadoc/net/sf/okapi/common/Event.html#getEventType()">Event.getEventType()</a></code>. The value retuned is one of the constants 
defined in <code>
<a href="../javadoc/net/sf/okapi/common/EventType.html">EventType</a></code>. Then, depending on the type, you can get 
the resource associated with this event (<code><a href="../javadoc/net/sf/okapi/common/Event.html#getResource()">Event.getResource()</a></code>) and access the data in the resource.</p>
<p>After the last event for the input document (<code>END_DOCUMENT</code>) has been read, <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#hasNext()">IFilter.hasNext()</a></code> 
returns false, and you can close the input. Note that it is a good practice for 
the filters to close the input themselves before sending the last event, but you 
should still call close just in case.</p>
<pre>// Get the events from the input document
while ( filter.hasNext() ) {
   Event event = filter.next();
   // do something with the event...
   // Here, if the event is TEXT_UNIT, we display the key and the extracted text
   if ( event.getEventType() == EventType.TEXT_UNIT ) {
      TextUnit tu = (TextUnit)event.getResource();
      System.out.println(&quot;--&quot;);
      System.out.println(&quot;key=[&quot;+tu.getName()+&quot;]&quot;);
      System.out.println(&quot;text=[&quot;+tu.getSource()+&quot;]&quot;);
   }
}
// Close the input document
filter.close();</pre>
<p>This should generate the following output:</p>
<pre>--
key=[key1]
text=[Text1]
--
key=[key2]
text=[Text2]</pre>
<h2><a name="modifyingDocument"></a>Modifying a Document</h2>
<p>Extracting the text parts of a document is useful, but a more useful feature 
the Okapi Framework offers is writing out the extracted data back into the 
original format.</p>
<p>As we have seen above, when you open a document with a filter, you can 
specify to generate the skeleton. The role of the skeleton is to 
store information about the parts of the input document that are not extractable, and to provide 
ways to merge back the parts that are extractable.</p>
<p>Because file formats are very different, they may need to use different types 
of skeleton mechanisms. For example, the skeleton for a binary file such as an OpenOffice.org ODT file (which is really a ZIP file) cannot be treated the same 
way as the skeleton of a Java properties file. The framework offers a 
transparent way to work with the different skeletons and lets the user ignore the 
underlying mechanism.</p>
<p>The skeleton parts are passed along with the resources of the 
events. A resource may or may not have an associated skeleton object.</p>
<p>To re-construct the original file format you need both the 
extracted resources and the skeleton parts passed through the events. The framework 
provides the <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html">IFilterWriter</a></code> 
interface to do all this transparently.</p>
<h3><a name="creatingFilterAndWriter"></a>Creating the Filter and the FilterWriter</h3>
<p>First, you must create the filter, just like before, except we will use 
the HTML filter this time:</p>
<pre>// Create a filter object
IFilter filter = new HtmlFilter();</pre>
<p>Next, you need to create an <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html">IFilterWriter</a></code> 
object. You do this by calling a method of the filter itself (<code><a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#createFilterWriter()">IFilter.createFilterWriter()</a></code>) 
that provides you with the proper implementation of <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html">IFilterWriter</a></code> 
for the given format it supports.</p>
<pre>// Create the filter writer
IFilterWriter writer = filter.createFilterWriter();</pre>
<h3><a name="configuringWriter"></a>Configuring the FilterWriter</h3>
<p>Once the <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html">IFilterWriter</a></code> 
object is created, you need to set its options. This is done with 
the <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html#setOptions(java.lang.String, java.lang.String)">IFilterWriter.setOptions()</a></code> method.</p>
<p>We need to set the output language. In this case we will use French. We also need to indicate which 
encoding to use for the out output. In our example, we will choose Latin-1.</p>
<pre>// Set the filter writer's options
writer.setOptions(LocaleId.fromString(&quot;fr&quot;), &quot;iso-8859-1&quot;);</pre>
<p>We also need to set where the output will be generated. The type of object 
used for output can be different from the one used for the input. For example, 
here we will use a string as the input document, and write the output to a 
physical file.</p>
<p>There are different methods to set the output:</p>
<ul>
	<li>Providing an <code>OutputStream</code> object.</li>
	<li>Providing a <code>URI</code> object pointing to a physical location.</li>
</ul>
<p>We are using the second method in this example:</p>
<pre>// Set the output
writer.setOutput(&quot;myFile_fr.html&quot;);</pre>
<p>Note that the output document is not created when you set the output, but 
only when the filter will start sending events.</p>
<p class="question"><b>Question:</b> Can the output file be the same as the input 
file?</p>
<p class="answer"><b>Answer</b>: Yes, you should be able to overwrite the input document. 
However, to ensure it will 
work, you should <b>always close the input document before closing the output 
document</b>.</p>
<h3>Opening the Input Document</h3>
<p>The next step is to open the input document with the filter. This time we 
will use an HTML string:</p>
<pre>// Open the input from a CharSequence
filter.open(new RawDocument(&quot;&lt;html&gt;&lt;head&gt;\n&quot;
   + &quot;&lt;meta http-equiv='Content-Language' content='en'&gt;&lt;/head&gt;\n&quot;
   + &quot;&lt;body&gt;\n&quot;
   + &quot;&lt;p&gt;Text in &lt;b&gt;bold&lt;/b&gt;.&lt;/p&gt;&quot;
   + &quot;&lt;/body&gt;&lt;/html&gt;&quot;, LocaleId.fromString(&quot;en&quot;)));</pre>
<h3><a name="processDocWithoutDhanges"></a>Processing the Document Without Making Changes</h3>
<p>Now that all is set, we can process the document.</p>
<p>Re-writing the input document is achieved simply: You call the <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html#handleEvent(net.sf.okapi.common.Event)">IFilterWriter.handleEvent()</a></code> method each time you get an event from 
the filter, and then close both input and output when all events have been 
processed. (Remember that you should always close the input document before the 
output document, in case you are writing to the same file).</p>
<pre>// Processing the input document
while ( filter.hasNext() ) {
   writer.handleEvent(filter.next());
}
// Closing the filter and the filter writer
filter.close();
writer.close();</pre>
<p>The code above should create a new file called <code>myFile_fr.html</code> 
in your current directory and its content should be like this:</p>
<pre>&lt;html>&lt;head>&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
&lt;meta http-equiv='Content-Language' content='fr'>&lt;/head>
&lt;body>
&lt;p>Text in &lt;b>bold&lt;/b>.&lt;/p>&lt;/body>&lt;/html></pre>
<p>As you can see, the filter writer make some modifications automatically: the HTML 
language declaration has been updated to reflect the target language you 
specified: &quot;<code>fr</code>&quot;. The remaining of the content is the same as the 
input.</p>
<h3><a name="processDocWithChanges"></a>Processing the Document and Making Changes</h3>
<p>Obviously the real interest of the filter writer is to save changes made to the 
extracted text into its original format.</p>
<p>To perform changes in the extracted text you need to handle the <code>
TEXT_UNIT</code> event, which comes with a <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html">TextUnit</a></code> 
resource where the source text is stored.</p>
<p>It is always good practice to isolate the place where you code your changes, so 
we will create a method for it. Our <code>changeTU()</code> method takes one 
parameter: The <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html">TextUnit</a></code> 
resource provided by the <code>TEXT_UNIT</code> event. The modifications are 
done directly in that object.</p>
<p>Before we do any change, we need to check if this text unit is actually 
translatable. While most of the extracted text is translatable, there are cases 
where, for different reasons, the provider of the events (here a filter) 
decided to protect the content of the text unit. A good example of this is the 
XLIFF filter: It returns one text unit for each <code>&lt;trans-unit&gt;</code> of the 
XLIFF document, but some of those <code>&lt;trans-unit&gt;</code> may have their 
<code>translate</code> 
attribute set to <code>no</code>. The <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#isTranslatable--">
TextUnit.isTranslatable()</a></code> method allows you to verify if a given text 
unit is translatable or not, as shown below:</p>
<pre>void changeTU (TextUnit tu) {
   // Check if this unit can be modified
   if ( !tu.isTranslatable() ) return; // If not, return without changes</pre>
<p>Once we have established that we can modify the text, we need to create a copy 
of the source content for the target.</p>
<p>One important thing to keep in mind when working with filters is that some 
input documents can be multilingual (for example a PO file, or an XLIFF 
document). Because of that you may actually already have a target text in your text unit.</p>
<p>The method <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#hasTarget(java.lang.String)">
TextUnit.hasTarget()</a></code> can check if a target for a given language 
exists already. But there is a more convenient way to create the target 
conditionally. The&nbsp; <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#createTarget(java.lang.String, boolean, int)">
TextUnit.createTarget()</a></code> is design for this. It takes several 
parameters:</p>
<ul>
	<li>The language of the target entry to create (here &quot;<code>fr</code>&quot;).</li>
	<li>
	<p>A flag indicating if you want to overwrite the content of a possible 
	existing target for that language. Set it to <code>true</code> to create a 
	new entry even if one exists already. Set it to <code>false</code> to use the 
	existing entry or to create a new entry if none exists.</li>
	<li>A flag indicating what to copy from the source. Use <code>
	IResource.COPY_ALL</code> to copy everything.</li>
</ul>
<pre>   TextContainer tc = tu.createTarget(LocaleId.fromString(&quot;fr&quot;), false, IResource.COPY_ALL);</pre>
<p>The result is a <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextContainer.html">
TextContainer</a></code> object, that holds all the target-related data: text, as 
well a properties, annotations, etc.</p>
<p class="question"><b>Question:</b> Is the language code case-sensitive?</p>
<p class="answer"><b>Answer</b>: No. When a language or a locale identifier is 
set to a <code>LocaleId</code> object, it is normalized, so &quot;<code>fr</code>&quot; and &quot;<code>FR</code>&quot; 
are seen as identical.</p>
<p>To make any modification to the content you need to work with a string of 
<a href="glossary.html#codedText">coded text</a>. It is a string with some special characters that markup 
<a href="glossary.html#inlineCode">inline 
codes</a>. Coded text string can usually be manipulated like a normal string, with 
some exceptions.</p>
<p>For this example, we want to convert the text to upper cases, and we can work 
without problem directly with the coded text. The content is accessible for each segment and we can use the
<code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#getCodedText--">
TextFragment.getCodedText()</a></code> method. When the conversion is done you 
have to set the modified string back into the <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html">
TextFragment</a></code> using the <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#setCodedText-java.lang.String-">
TextFragment.setCodedText()</a></code> method.</p>
<pre>   ISegments segs = tc.getSegments();
   for ( Segment seg : segs ) {
      TextFragment tf = seg.getContent();
      tf.setCodedText(tf.getCodedText().toUpperCase());
   }
}</pre>
<p>With our <code>changeTU()</code> method done, we can now add it to the main 
loop of the filter's event.</p>
<pre>while ( filter.hasNext() ) {
   Event event = filter.next();
   if ( event.getEventType() == EventType.TEXT_UNIT ) {
      changeTU((TextUnit)event.getResource());
   }
   writer.handleEvent(event);
}
filter.close();
writer.close();</pre>
<p>The output of our new program should look like this:</p>
<pre>&lt;html>&lt;head>&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
&lt;meta http-equiv='Content-Language' content='fr'>&lt;/head>
&lt;body>
&lt;p>TEXT IN &lt;b>BOLD&lt;/b>.&lt;/p>&lt;/body>&lt;/html></pre>
<h2><a name="textUnits"></a>Working with Text Units</h2>
<p>One of the most important events generated by the filters is the <code>
TEXT_UNIT</code> event. It corresponds to a logical unit of extractable text of 
the input document. For example, the content of a <code>&lt;p&gt;</code> element in 
HTML, or the value of a key/value pair in a Java properties file. A text unit 
corresponds more or less to a <code>&lt;trans-unit&gt;</code> element in XLIFF.</p>
<p>The text unit holds source and target data for the given extracted text, as 
well as properties (for the whole unit, for the source, as well as for each 
target), and annotations (also for the whole unit, for the source, as well as 
for each target). It is also hold its corresponding skeleton object (if there is 
one).</p>
<p>The bottom line is that you can access the source text from the text unit, as 
well create new translation entries or access existing ones (if the input 
document is multilingual).</p>
<p>Each language has a corresponding
<a href="../javadoc/net/sf/okapi/common/resource/TextContainer.html">
<code>
TextContainer</code></a> object that holds the text as well as its associated 
properties and annotations. the text itself is in a
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> object. Those parts are easily accessible from the 
text unit:</p>
<pre>TextUnit tu = new TextUnit(&quot;id1&quot;);
tu.setSourceContent(new TextFragment(&quot;My text&quot;));

TextContainer tc = tu.getSource();
TextFragment tf1 = tc.getContent();
// Or
TextFragment tf2 = tu.getSourceContent();</pre>
<p>In the example above both <code>tf1</code> and <code>tf2</code> point to the 
same object: The source text content of the text unit.</p>
<p>Once you have a
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> you can manipulate it almost like a classic string:</p>
<pre>tf1.append(' ');
tf1.append(&quot;is this.&quot;);
// Prints &quot;My text is this&quot;
System.out.println(tf1.toString());

tf1.insert(3, new TextFragment(&quot;first &quot;));
// Prints &quot;My first text is this.&quot;
System.out.println(tf1.toString());

tf1.remove(13, 21);
// Prints &quot;My first text.&quot;
System.out.println(tf1.toString());</pre>
<p dir="ltr">There is, however, one major difference between a <a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html">
    <code>TextFragment</code></a>
and a string: the inline codes.</p>
<h3><a name="inlineCodes"></a>Inline Codes</h3>
<p>Inline codes are spans of the extracted content that are not real text, but 
codes/markup embedded in the text. They often represent formatting information. For example, in the HTML content &quot;<code>Text in &lt;b&gt;bold&lt;/b&gt;.</code>&quot; 
the two tags &quot;<code>&lt;b&gt;</code>&quot; and &quot;<code>&lt;/b&gt;</code>&quot; are inline codes.</p>
<p>A
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"> <code>
	TextFragment</code></a> 
object can contain many inline codes:</p>
<pre>TextUnit tu = new TextUnit(&quot;id1&quot;);
TextFragment tf = tu.setSourceContent(new TextFragment(&quot;Text in &quot;));
tf.append(TagType.OPENING, &quot;bold&quot;, &quot;&lt;b&gt;&quot;);
tf.append(&quot;bold&quot;);
tf.append(TagType.CLOSING, &quot;bold&quot;, &quot;&lt;/b&gt;&quot;);
tf.append(&quot;.&quot;);
// Prints &quot;Text in &lt;b&gt;bold&lt;/b&gt;.&quot;
System.out.println(tf.toString());</pre>
<p>Separating text from code allows translation tools to work in a more abstract 
way. For example an RTF text &quot;<code>Text in {\b bold}.</code>&quot; and an HTML text 
&quot;<code>Text in &lt;b&gt;bold&lt;/b&gt;.</code>&quot; can be represented the same way in a
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a>. This allows better handling of the content: Improve translation memory leveraging; 
comparing codes between 
source and target; working with the text (e.g. spell-checking) without having 
the code be in the way; and much more.</p>
<p>The content is separated into two parts: a coded text string where you 
have the real text and special markers for each code; and the list of the codes 
themselves. You can access the coded text with the <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#getCodedText(int, int)">
TextFragment.getCodedText()</a></code> method, and the list of codes with the
<code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#getCodes()">
TextFragment.getCodes()</a></code> method. Most of the time simple utilities 
need only to access the coded text.</p>
<pre>String text = tf.getCodedText();
List&lt;Code&gt; codes = tf.getCodes();</pre>
<p>The coded text part contains placeholders to represent the inline codes. each 
one is composed of two special Unicode characters:</p>
<ol>
	<li>The first one represent the 
kind of inline code:<ul>
		<li>U+E101: opening</li>
		<li>U+E102: closing</li>
		<li>U+E103: standalone</li>
		<li>There is also a special character U+E104 that is
		<a href="segmentation.html#segmentedContent">used for segment placeholder</a> when 
the text is segmented.</li>
	</ul>
	</li>
	<li>The second one is the zero-based index of the code in the list of codes, 
	starting at U+E110.</li>
</ol>
<p>All these special 
characters are in the Private Use Area of Unicode.</p>
<pre>Normal: &quot;Text in <span style="background-color: #FFFF00">&lt;b&gt;</span>bold<span style="background-color: #00FF00">&lt;/b&gt;</span>.&quot;
 Coded: &quot;Text in <span style="background-color: #FFFF00">\uE101\uE110</span>bold<span style="background-color: #00FF00">\uE102\uE111</span>.&quot;</pre>
<p>The following method takes a
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> and counts the number of characters in the real 
text part of the coded text. You can use the <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#isMarker(char)">
TextFragment.isMarker()</a></code> helper method to check if a given character 
is an inline code marker or not. If it is one, you need to skip the next 
character as it represents the index of the inline code to the list of codes.</p>
<pre>private static int countChars (TextFragment tf) {
   String text = tf.getCodedText();
   int count = 0;
   for ( int i=0; i&lt;text.length(); i++ ) {
      if ( TextFragment.isMarker(text.charAt(i)) ) i++;
      else count++;
   }
   return count;
}</pre>
<p>If you apply the method above to our
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> and compare it to the other length counts you get:</p>
<ul>
	<li><code>tf.getString().length()</code> = 20</li>
	<li><code>tf.getCodedText().length()</code> = 17</li>
	<li><code>countChars(tf)</code> = 13</li>
</ul>
<h3><a name="modifyingText"></a>Modifying Text</h3>
<p>If you modify a coded text string, you need to set the modified string back 
into the
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> object. This is done with one of the <code>
TextFragment.setCodedText()</code> methods.</p>
<p>The first method sets the coded text, and re-uses the codes that are 
currently in the
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a>. This implies that the inline code markers in the 
coded text you have modified must be unchanged. Extra or missing codes will 
trigger an error.</p>
<pre>// Prints &quot;Text in &lt;b&gt;bold&lt;/b&gt;.&quot;
System.out.println(tf.toString());

String text = tf.getCodedText();
text = text.toUpperCase();
tf.setCodedText(text);

// Prints &quot;TEXT IN &lt;b&gt;BOLD&lt;/b&gt;.&quot;
System.out.println(tf.toString());</pre>
<p>The second method is to set the new coded text and indicate that missing 
inline code markers in your new text means the corresponding codes in the
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> should be deleted. Only extra codes will trigger an 
error.</p>
<pre>// Prints &quot;TEXT IN &lt;b&gt;BOLD&lt;/b&gt;.&quot;
System.out.println(tf.toString());

text = tf.getCodedText();
text = text.substring(0, 14);
// Allows the deletion of &quot;&lt;/b&gt;&quot;
tf.setCodedText(text, true);

// Prints &quot;TEXT IN &lt;b&gt;BOLD&quot;
System.out.println(tf.toString());</pre>
<p class="question"><b>Question</b>: When the &quot;<code>&lt;b&gt;</code>&quot; code was 
originally added to the text it was set with a <code>TagType.OPENING</code> 
flag. Now that it does not have a corresponding closing tag, don't we have to 
change its type to something else?</p>
<p class="answer"><b>Answer</b>: No. The <code>TagType</code> flag remains the same 
(&quot;<code>&lt;b&gt;</code>&quot; is still a start tag). But the marker in the coded text for 
this inline code should now be <code>MARKER_ISOLATED</code> instead of <code>
MARKER_OPENING</code>. This change was done automatically for you when we called <code>
setCodedText()</code>. We will see more information about how tag types and 
markers relate to each other later.</p>
<p>The third method is to specify the list of codes along with the modified 
coded text. This allows you complete control over the inline codes. If the list 
of codes you provide does not match the inline codes in the coded text string it 
will trigger an error.</p>
<pre>// Prints &quot;TEXT IN &lt;b&gt;BOLD&quot;
System.out.println(tf.toString());

text = tf.getCodedText();
// Create a new set of codes
List&lt;Code&gt; codes = new ArrayList&lt;Code&gt;();
codes.add(new Code(TagType.OPENING, &quot;italic&quot;, &quot;&lt;i&gt;&quot;));
codes.add(new Code(TagType.CLOSING, &quot;italic&quot;, &quot;&lt;/i&gt;&quot;));
// Replace the text &quot;BOLD&quot; by &quot;ITALIC&quot;
text = text.replace(&quot;BOLD&quot;, &quot;ITALIC&quot;);
// Add the marker for the new second inline code
text += (char)TextFragment.MARKER_CLOSING;
text += TextFragment.toChar(1);
tf.setCodedText(text, codes);

// Prints &quot;TEXT IN &lt;b&gt;ITALIC&lt;/b&gt;.&quot;
System.out.println(tf.toString());</pre>
<p>In the code above, note the use of the <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#toChar(int)">
TextFragment.toChar()</a></code> helper method to add the index of the new 
inline code just after the marker. It allows you to convert a code index into 
its special character representation. The reverse method <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#toIndex(char)">
TextFragment.toIndex()</a></code> converts a given character into a code index 
value.</p>
<p>Lastly, you can specify the list of codes along with the modified 
coded text, as well as a flag indicating if missing codes can be removed from 
the provided list of codes. For example, the code below removes all the codes 
and replaces the text with a new one.</p>
<pre>// Prints &quot;TEXT IN &lt;b&gt;ITALIC&lt;/b&gt;.&quot;
System.out.println(tf.toString());

// Remove all inline codes
tf.setCodedText(&quot;Normal text.&quot;, null, true);

// Prints &quot;Normal text.&quot;
System.out.println(tf.toString());</pre>
<h3><a name="tagTypeAndMarkers"></a>TagType and Marker</h3>
<p>Each inline code is associated with a <code>TagType</code> information. It 
can be <code>OPENING</code>, <code>CLOSING</code>, or <code>PLACEHOLDER</code>. 
(It can also be <code>SEGMENTHOLDER</code> in some cases of segmented entries, 
but we will ignore this for now).</p>
<p>You specify this information when adding the code to the fragment:</p>
<pre>tf.append(TagType.OPENING, &quot;bold&quot;, &quot;&lt;b&gt;&quot;);
tf.append(TagType.CLOSING, &quot;bold&quot;, &quot;&lt;/b&gt;&quot;);
tf.append(TagType.PLACEHOLDER, &quot;lb&quot;, &quot;&lt;br/&gt;&quot;);</pre>
<p>You can retrieve it later:</p>
<pre>assert(tf.getCode(0).getTagType() == TagType.OPENING);
assert(tf.getCode(1).getTagType() == TagType.CLOSING);
assert(tf.getCode(2).getTagType() == TagType.PLACEHOLDER);</pre>
<p>This information normally remains unchanged: The code &quot;<code>&lt;b&gt;</code>&quot; is 
always a start tag regardless of where it is and whether or not it has a corresponding
closing tag.</p>
<p>There is a difference however between what the tag is and how it should be 
represented and manipulated from the viewpoint of an extracted segment. That 
information is related to the position of the inline code in the text and is 
denoted through the kind of markers used to hold the spot of the code in the 
coded text. There are several markers: <code>MARKER_OPENING</code>, <code>
MARKER_CLOSING</code> and <code>MARKER_ISOLATED</code>. (There is also a <code>
MARKER_SEGMENT</code> <a href="segmentation.html#segmentedContent">used in segmented entries</a>, but we will ignore this for 
now).</p>
<p>When a code with <code>TagType.OPENING</code> or <code>TagType.CLOSING</code> 
is alone in a fragment, or otherwise separated from its corresponding closing 
or opening counterpart, the marker is not set to <code>MARKER_OPENING</code> or
<code>MARKER_CLOSING</code>, but to <code>MARKER_ISOLATED</code>, but it <code>
TagType</code> remains unchanged.</p>
<p>For example, in the code below, the closing &quot;<code>&lt;/b&gt;</code>&quot; originally 
set with a <code>MARKER_CLOSING</code>, is changed to a <code>MARKER_ISOLATED</code> 
when the text is broken into two sentences in different fragments:</p>
<pre>Normal: &quot;First <span style="background-color: #FFFF00">&lt;b&gt;</span>bold. Second one<span style="background-color: #00FF00">&lt;/b&gt;</span>.&quot;
 Coded: &quot;First <span style="background-color: #FFFF00"><b>\uE101</b>\uE110</span>bold. Second one<span style="background-color: #00FF00"><b>\uE102</b>\uE111</span>.&quot;
 Codes:  <span style="background-color: #FFFF00">0</span>={&quot;&lt;b&gt;&quot;,TagType.OPENING},
         <span style="background-color: #00FF00">1</span>={&quot;&lt;/b&gt;&quot;,TagType.OPENING}</pre>
<div dir="ltr">
<pre>Normal f1: &quot;First <span style="background-color: #FFFF00">&lt;b&gt;</span>bold. &quot;
 Coded f1: &quot;First <span style="background-color: #FFFF00"><b>\uE103</b>\uE110</span>&quot; (\uE101 becomes \uE103)
 Codes f1: <span style="background-color: #FFFF00">0</span>={&quot;&lt;b&gt;&quot;,TagType.OPENING}

Normal f2: &quot;Second one<span style="background-color: #00FF00">&lt;/b&gt;</span>.&quot;
 Coded f2: &quot;Second one<span style="background-color: #00FF00"><b>\uE103</b>\uE110</span>.&quot; (\uE102 becomes \uE103)
 Codes f2: <span style="background-color: #00FF00">0</span>={&quot;&lt;/b&gt;&quot;,TagType.CLOSING}</pre>
</div>
<p>&nbsp;</p>

</body>

</html>