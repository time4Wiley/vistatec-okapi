<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>Sample: title</title>
</head>
<body>
    <h1>
        ASCII -- The American Standard Code for Information Interchange</h1>
    <p />
    <h2>
        Introduction</h2>
    <p>
        The ASCII code was the first 8-bit standard code that let characters - letters,numbers,
        punctuation, and other symbols - be represented by the same 8-bits on many different
        kinds of computers. It is limitted to the alphabet popular at the time in the USA
        but was adopted internationally( see ISO_Latin_1). Prior to ASCII each computer
        manufacturer tended to use their own code. IBM for example had EBCDIC. These might
        be ad hoc, based on pattern of holes punched on cards, based on the pattern of holes
        punched in paper tape, or the sequence of bits transmitted by teletypes on the Telex
        (telegram) network.</p>
    <p />
    <p>
        ASCII is the code used on the Internet. In the 1990&#39;s a 16-bit code was developed
        that will handle alphabets of many nations. It contains the ASCII sequence. The
        new code is called UNICODE.</p>
    <p />
    <p>
        The ASCII code includes control characters that do not print a character. These
        have a short standard name, a standard function plus a large number of non-standard
        applications.</p>
    <p />
    <p>
        The original code was developed in the days of mechanical terminals such as Teletypes.
        The meaning of the control codes are defined in terms of typewriter like actions
        - Tab, ring bell, back-space, return, and line feed. A competent software engineer will know about the control codes;
        what they were designed to mean, and how they are used or mis-used in real systems.</p>
    <p />
    <p>
        In many high level languages the ASCII characters are representable as a function,
        (eg Pascal - chr(i), C - (char)i, or Ada - CHAR&#39;VAL(i) ) where &quot;i&quot;
        is an integer. Ada specifies a special standard package that defines ASCII with
        standard names for constants representing the coded character. In C they can be
        indicated by a backslash character (\) followed by either a special letter, or as
        a hexadecimal or octal number. The following dictionary defines the ASCII name,
        its position in the ASCII code, its original meaning, and Ada 83 symbol.</p>
    <p />
    <h2>
        Control characters</h2>
    <p />
    <p>
        ASCII::=</p>
    <div>
        <p>
            Net{</p>
        <p>
            There are 128 ASCII codes numbered from 0 to 128. I will use the notation of</p>
        <pre>      character_nbr(i)</pre>
        <p>
            to indicate the i&#39;th ASCII character:</p>
        <p>
            character_nbr::0..127---char, -- The &quot;---&quot; indicates that there are precisely
            128 standard characters that correspond, one-for-one, to their code numbers 0..127.</p>
        <pre>      $character_nbr(65)</pre>
        <p>
            is &quot;A&quot;. I use the C/C++ abbreviation to indicate the set of all ASCII
            codes:</p>
        <p />
        <p>
            char::= character_nbr(0..127), --all the ASCII codes.</p>
        <p>
            CTRL_CHARS::=</p>
        <div>
            <p>
                Net{</p>
            <p>
                NUL::= character_nbr(0)::= <span>Fills in time* (ASCII&#39;NUL)</span>.</p>
            <p>
                SOH::= character_nbr(1)::= <span>Start Of Header (routing info)(ASCII&#39;SOH)</span>.</p>
            <p>
                STX::= character_nbr(2)::= <span>Start Of Text (end of header)(ASCII&#39;STX)</span>.</p>
            <p>
                ETX::= character_nbr(3)::= <span>End Of Text(ASCII&#39;ETX)</span>.</p>
            <p>
                EOT::= character_nbr(4)::= <span>End Of Transmission(ASCII&#39;EOT)</span>.</p>
            <p>
                ENQ::= character_nbr(5)::= <span>ENQuiry, asking who is there(ASCII&#39;ENQ)</span>.</p>
            <p>
                ACK::= character_nbr(6)::= <span>Receiver ACKnowledges positively(ASCII&#39;ACK)</span>.</p>
            <p>
                bell::= BEL.</p>
            <p>
                BEL::= character_nbr(7)::= <span>Rings BELl or beeps(ASCII&#39;BEL)\a</span>.</p>
            <p>
                backspace::= BS.</p>
            <p>
                BS::= character_nbr(8)::= <span>Move print head Back one Space(ASCII&#39;BS)\b</span>.</p>
            <p>
                HT::= character_nbr(9)::= <span>Move to next Tab-stop(ASCII&#39;HT)\t</span>.</p>
            <p>
                LF::= character_nbr(10)::= <span>Line Feed (ASCII&#39;LF)\n</span>.</p>
            <p>
                VT::= character_nbr(11)::= <span>Vertical Tabulation(ASCII&#39;VT)\v</span>.</p>
            <p>
                FF::= character_nbr(12)::= <span>Form Feed - skip to new page(ASCII&#39;FF)\f</span>.</p>
            <p>
                CR::= character_nbr(13)::= <span>Carriage Return to left margin(ASCII&#39;CR)\r</span>.</p>
            <p>
                SO::= character_nbr(14)::= <span>Shift Out of ASCII(ASCII&#39;SO)</span>.</p>
            <p>
                SI::= character_nbr(15)::= <span>Shift into ASCII(ASCII&#39;SI)</span>.</p>
            <p>
                DLE::= character_nbr(16)::= <span>Data Link Escape(ASCII&#39;DLE)</span>.</p>
            <p>
                DC1::= character_nbr(17)::= <span>Device control(ASCII&#39;DC1)</span>.</p>
            <p>
                DC2::= character_nbr(18)::= <span>Device control(ASCII&#39;DC2)</span>.</p>
            <p>
                DC3::= character_nbr(19)::= <span>Device control(ASCII&#39;DC3)</span>.</p>
            <p>
                DC4::= character_nbr(20)::= <span>Device control(ASCII&#39;DC4)</span>.</p>
            <p>
                NAK::= character_nbr(21)::= <span>Negative Acknowledgment(ASCII&#39;NAK)</span>.</p>
            <p>
                SYN::= character_nbr(22)::= <span>Sent in place of data to keep systems synchronized(ASCII&#39;SYN)</span>.</p>
            <p>
                ETB::= character_nbr(23)::= <span>End of transmission block(ASCII&#39;ETB)</span>.</p>
            <p>
                CAN::= character_nbr(24)::= <span>Cancel previous data(ASCII&#39;CAN)</span>.</p>
            <p>
                EM::= character_nbr(25)::= <span>End of Medium(ASCII&#39;EM)</span>.</p>
            <p>
                SUB::= character_nbr(26)::= <span>Substitute(ASCII&#39;SUB)</span>.</p>
            <p>
                escape::= ESC.</p>
            <p>
                ESC::= character_nbr(27)::= <span>Escape to extended character set(ASCII&#39;ESC)</span>.</p>
            <p>
                FS::= character_nbr(28)::= <span>File separator(ASCII&#39;FS)</span>.</p>
            <p>
                GS::= character_nbr(29)::= <span>Group separator(ASCII&#39;GS)</span>.</p>
            <p>
                RS::= character_nbr(30)::= <span>Record separator(ASCII&#39;RS)</span>.</p>
            <p>
                US::= character_nbr(31)::= <span>Unit separator(ASCII&#39;US)</span>.</p>
            <p>
                space::= SP.</p>
            <p>
                SP::= character_nbr(32)::= <span>Blank Space character(ASCII&#39;SP)</span>.</p>
            <p>
                delete::= DEL.</p>
            <p>
                DEL::= character_nbr(127)::= <span>Punch out all bits on paper tape(delete)</span>.</p>
                        <p>
                }=:: CTRL_CHARS.</p>
        </div>
        <p />
        <h2>
            Normal Characters</h2>
        <p>
            OTHER_CHARS::=</p>
        <div>
            <p>
                Net{</p>
            <p>
                The Ada standard defines a name for all printable characters. MATHS inherits these
                and adds some. Here are the standard MATHS names for the common characters in ASCII.</p>
            <p>
                exclam::= character_nbr(33)::=&quot;!&quot;.</p>
            <p>
                quotes::= character_nbr(34)::=&quot;\&quot;&quot;.</p>
            <p>
                number::= hash.</p>
            <p>
                sharp::= hash.</p>
            <p>
                hash::= character_nbr(35)::=&quot;#&quot;, also called the &quot;octothorpe&quot;.</p>
            <p>
                dollar::= character_nbr(36)::=&quot;$&quot;.</p>
            <p>
                per_cent::= character_nbr(37)::=&quot;%&quot;.</p>
            <p>
                ampersand::= character_nbr(38)::=&quot;&amp;&quot;.</p>
            <p>
                apostrophe::= character_nbr(39)::=&quot;&#39;&quot;.</p>
            <p>
                l_paren::= character_nbr(40)::=&quot;(&quot;.</p>
            <p>
                r_paren::= character_nbr(41)::=&quot;)&quot;.</p>
            <p>
                asterisk::= star, also known as &quot;splat&quot;.</p>
            <p>
                star::= character_nbr(42)::=&quot;*&quot;.</p>
            <p>
                plus::= character_nbr(43)::=&quot;+&quot;, also called the &quot;quadrathorpe&quot;.</p>
            <p>
                comma::= character_nbr(44)::=&quot;,&quot;.</p>
            <p>
                minus::= character_nbr(45)::=&quot;-&quot;.</p>
            <p>
                dot::= character_nbr(46)::=&quot;.&quot;, used as a decimal point and end of sentence
                in many cultures.</p>
            <p>
                divide::= slash.</p>
            <p>
                slash::= character_nbr(47)::=&quot;/&quot;.</p>
            <p>
                digits::= character_nbr(48)..character_nbr(57).</p>
            <p>
                colon::= character_nbr(58)::=&quot;:&quot;.</p>
            <p>
                semicolon::= character_nbr(59)::=&quot;;&quot;.</p>
            <p>
                less_than::= character_nbr(60)::=&quot;&lt;&quot;.</p>
            <p>
                equal::= character_nbr(61)::=&quot;=&quot;.</p>
            <p>
                greater_than::= character_nbr(62)::=&quot;&gt;&quot;.</p>
            <p>
                query::= character_nbr(63)::=&quot;?&quot;.</p>
            <p>
                at_sign::= character_nbr(64)::=&quot;@&quot;.</p>
            <p>
                upper_case_letters::=character_nbrs(65).. character_nbr(90).</p>
            <p>
                l_bracket::= character_nbr(91)::=&quot;[&quot;.</p>
            <p>
                backslash::= character_nbr(92)::=&quot;\&quot;.</p>
            <p>
                r_bracket::= character_nbr(93)::=&quot;]&quot;.</p>
            <p>
                caret::= circumflex.</p>
            <p>
                circumflex::= character_nbr(94)::=&quot;^&quot;.</p>
            <p>
                underscore::= character_nbr(95)::=&quot;_&quot;.</p>
            <p>
                grave::= reverse_quote.</p>
            <p>
                reverse_quote::= character_nbr(96)::=&quot;`&quot;.</p>
            <p>
                lower_case_letters::= character_nbr(97)..character_nbr(122). Corrected Tue Jul 29
                2003 by jklipa of Hot Mail.</p>
            <p>
                l_brace::= character_nbr(123)::=&quot;{&quot;.</p>
            <p>
                bar::= character_nbr(124)::=&quot;|&quot;.</p>
            <p>
                r_brace::= character_nbr(125)::=&quot;}&quot;.</p>
            <p>
                tilde::= character_nbr(126)::=&quot;~&quot;.</p>
            <p>
                Character number 127 is the DEL control character.</p>
                        <p>
                }=:: OTHER_CHARS.</p>
        </div>
        <p />
        <h2>
            Note -- DISCONNECT and BREAK etc</h2>
        <p>
            Notice that NO ASCII character sends a signal that terminates transmission. This
            is not a character. It is transmitted thru an RS232 cable by dropping the DTR line
            to the signal ground, or thru a modem by ceasing to send the carrier frequency for
            a fixed length of time. Some people call this a DISCONNECT and others call it BREAK
            (in my experience).</p>
        <p>
            NUL transmits a character (with all bits=0), DISCONNECT does not.</p>
        <p>
            Tom Zerucha (June 2009) notes that a BREAK -- in the sense of an attempt to interrupt
            a process. He writes</p>
        <hr />
        <div>
            <p>
                A standard break, or &quot;attention&quot; is NOT dropping the DTR line or stopping
                the carrier which will normally DISCONNECT.</p>
            <p>
                A break is sent by holding down the tranmit data line to the state that would transmit
                a zero bit, causing a framing error. Normal ASCII is transmitted using a zero start-bit,
                data bits, optional parity bits, and a one for a stop bit. A break will look like
                a null (0x00) but not have any stop bit until the break is released.</p>
            <p>
                This would be an out-of-band signal, but the other lines including data terminal
                ready (DTR) would remain in their normal state for a connection.</p>
        </div>
        <p>
            Most older systems also interpretted some of the control characters as an interupt.
            For example CTRL/C was commonly used. And on UNIXen CTRL/Z interupts a running program
            but suspends it. You can then use the UNIX commands like &quot;kill&quot; and UNIX
            shell commands like &quot;bg&quot; and &quot;fg&quot; to control the process.</p>
        <p />
        <h1>
            Whitespace</h1>
        <p>
            whitespace::= whitespace_char #(whitespace_char).</p>
        <p>
            whitespace_char::= SP | CR | LF | HT | ... .</p>
        <h1>
            End of line strings</h1>
        <p>
            EOLN::= <span>End Of Line string -- depends on the system you are using</span>.</p>
        <p>
            |- <span>EOLN ==&gt; ( CR | LF) #( CR | LF | HT | VT | ...).</span> [ 001319.html
            ] (Coding Horror on the the great line break schism).
        </p>
        <h1>
            Periods and Decimal Points</h1>
        <p>
            In COBOL and MATHS the &quot;.&quot; character is both a punctuator and a decimal
            point. The following defines the cases when a &quot;.&quot; is acting as a punctuator:</p>
        <p>
            period::=&quot;.&quot; whitespace,-- A dot followed by white space is treated as
            a period.</p>
        <p>
            Note that in Europe, a comma is used in numbers as the decimal point.</p>
        <h1>
            Standard Character Sets</h1>
        <p>
            char is the set of all ASCII characters.</p>
        <p />
        <p>
            digit::=&quot;0&quot;..&quot;9&quot;. See digits.</p>
        <p>
            letter::= upper_case_letter | l lower_case_letter.</p>
        <p>
            upper_case_letter::=&quot;A&quot;..&quot;Z&quot;. See upper_case_letters: characters
            65..90.</p>
        <p>
            lower_case_letter::=&quot;a&quot;..&quot;z&quot;. See lower_case_letters: characters
            97..122.
        </p>
        <h1>
            Useful mappings</h1>
        <p>
            The upper and lower case letters have a traditional one-to-one correspondence:</p>
        <pre>
			   Upper   ABCDEFGHIJKLMNOPQRSTUVWXYZ</pre>
        <pre>
			   Lower   abcdefghijklmnopqrstuvwxyz</pre>
        <p>
            So subtracting 32 from the number of an lower-case character gives and upper-case
            character.</p>
        <p>
            The following define some maps that help to define the syntax of case insensitive
            languages.</p>
        <p>
            to_upper::lower_case---upper_case, this is a one-to-one map between the cases.</p>
        <p>
            <span>For l:lower_case, to_upper(l)= character_nbr( l./character_nbr - 32 ).</span>
        </p>
        <p>
            to_upper::char-&gt;char= to_upper |+&gt; Id, extending to all ASCII characters.</p>
        <p>
            to_upper::#char-&gt;#char= &quot;&quot;+&gt;&quot;&quot; |+&gt; (1st;to_upper rest;to_upper),
            extending to strings of characters.</p>
        <p>
            <span>to_upper(&quot;123abc+x/Z&quot;)= to_upper(&quot;1&quot;) to_upper(&quot;23abc+x/Z&quot;)=&quot;123ABC+X/Z&quot;.</span>
        </p>
        <p>
            to_lower::upper_case---lower_case= /to_lower.</p>
        <p>
            to_lower::char-&gt;char= to_lower|+&gt;Id.</p>
        <p>
            to_lower::#char-&gt;#char= &quot;&quot;+&gt;&quot;&quot; |+&gt; (1st;to_lower rest;to_lower).</p>
        <p>
            <span>to_lower(&quot;123abc+x/Z&quot;)=&quot;123abc+x/z&quot;.</span></p>
        <p>
            Notice that to_lower and to_upper are not inverse function when applied to strings
            of mix-cased characters:</p>
        <p>
            <span>to_upper(to_lower(&quot;aA&quot;))=&quot;AA&quot; &lt;&gt; &quot;aA&quot;.</span>
        </p>
        <p>
            The above maps were implemented in C and are now part of the C++ cctype [ c++.libraries.html#cctype
            ] library.</p>
        <p>
            ignore_case::char-&gt;@char=map[c:char]( to_lower(c) | to_upper(c) ).</p>
        <p>
            <span>ignore_case(&quot;h&quot;) = &quot;h&quot; | &quot;H&quot;.</span>
        </p>
        <p>
            ignore_case::#char-&gt;@#char= &quot;&quot;+&gt;{&quot;&quot;} |+&gt; (1st;ignore_case
            rest;ignore_case).</p>
        <p>
            <span>ignore_case(&quot;href&quot;)=(&quot;h&quot;|&quot;H&quot;) (&quot;r&quot;|&quot;R&quot;)
                (&quot;e&quot;|&quot;E&quot;) (&quot;f&quot;|&quot;F).</span>
        </p>
        <p>
            equal_but_for_case::@(#char, #char), an equivalence relation on strings.
        </p>
                <p>
            |- <span>equal_but_for_case = rel[x,y](to_upper(x)=to_upper(y)).</span>
        </p>
                <p>
            ( above)|- <span>&quot;a1Z&quot; equal_but_for_case &quot;A1z&quot;.</span></p>
                <p>
            }=:: ASCII.</p>
    </div>
    <h1>
        Extensions</h1>
    <p>
        EXTENDED_ASCII::=following,</p>
    <p>
        Net</p>
    <div>
        <p>
            On many modern computers ASCII treast the parity bit as data and so there are 256
            different characters:</p>
        <p>
            character_nbr::0..255---extended_char, -- The &quot;---&quot; indicates that there
            are precisely 128 standard characters that correspond, one-for-one, to their code
            numbers.</p>
        <p>
            extended_char::= character_nbr(0..255). The standard ASCII code still work:
        </p>
        <p>
            |- <span>ASCII.</span></p>
                <p>
            (End of Net)</p>
    </div>
    <h1>
        See Also</h1>
    <p>
        Information on ASCII [ ASCII ] [ ascii.html ] and other codes [ http://www.lookuptables.com/
        ]</p>
    <p>
        Tables of ISO Latin 1 codes:</p>
    <p>
        ISO_Latin_1::= See http://www.bbsinc.com/symbol.html
    </p>
    <p>
        16-bit international code:</p>
    <p>
        UNICODE::= See http://www.csci.csusb.edu/dick/samples/glossary.html#UNICODE.
    </p>
    <h1>
        Notes on special uses of special characters</h1>
    <hr />
    <p>
        The following have been used to mark the end of a string: NUL, ESC, 2 ESCs, grave
        accent, apostrophe, quotation, EOLN, slash.</p>
    <p>
        The following have been used to indicate the end of input: EOT, SUB, 2 CRs</p>
    <p>
        The following have been used to kill or delete the previous character: DEL, BS,
        #.</p>
    <p>
        The following have been used to cancel the current line of input: DEL, NAK(^U),
        hash(#)</p>
    <p>
        On a network the special character take on yet more meanings. For example, commonly
        RS232 communications use DC3(^S) and DC1(^Q) to delay and restart data transmission
        (originally to allow data to be punched). In an X.25 packet switched network SI(^O)
        forces the data through the intervening machines and DLE(^P) allows you to send
        commands to your local &quot;Pad&quot;. Proprietary networks often have a special
        &#39;escape&#39; character as well.</p>
    <p>
        The following can allow a following control character to appear in text: SYN(^V),</p>
    <p>
        . . . . . . . . . ( end of section ASCII -- The American Standard Code for Information
        Interchange) &lt;&lt;Contents | End &gt;&gt;</p>
    <h3>
        End</h3>
</body>
</html>
